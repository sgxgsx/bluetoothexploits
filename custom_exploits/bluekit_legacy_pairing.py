import argparse
import os
import logging
import subprocess
import signal
import psutil
import time

from bluekit.report import report_vulnerable, report_not_vulnerable, report_error
from bluekit.constants import LOG_FILE

HCITOOL_SCAN = "sudo hcitool scan"
HCITOOL_INFO = "sudo hcitool info {target}"
BLUETOOTHCTL_PAIR = "bluetoothctl pair {target}"
BLUETOOTHCTL_REMOVE = "bluetoothctl remove {target}"
BLUETOOTHCTL_CONNECT = "bluetoothctl connect {target}"
BT_AGENT_NINO = "bt-agent -c DisplayYesNo"


INSTRUCTIONS = """
1. Have your target device in discoverable and pairable mode. Always keep it that way
2. Once the promt to connect appears. Observe the following:
3. The target would show a 4-6 digit code, e.g. 0000 and ask you to enter it. If it mentions PIN then it's vulnerable. There won't be any confirmation dialog on a target device.
4. Remember this code.
5. The exploit would eventually drop connection and start a new one.
6. The target would show you a 4-6 digit code again. If it's the same as your remembered. Then the target device uses legacy pairing
7. The exploit would again drop a connection and show you a prompt. 
8. Please enter Yes if the device was vulnerable, if not then enter No. If you had an error e.g. you didn't see any prompt on your device, then enter Error.


Additionally:
If you want to test the device yourself. You can use your mobile phone. Simply ask to pair with a target device, 
if it shows you the same code as before and asks you to enter it in a box - then it uses Legacy Pairing.

Legacy pairing is dangerous due to at least 2 attacks on it: 
1. Breaking encryption, deriving the keys and doing a passive MitM
2. Doing an active MitM as the code never changes.


## NOTE:: Not tested on a device with legacy pairing

"""


def check_legacy_pairing(target):
    try:
        # Changing BT Agent to NoInputNoOutput
        process = subprocess.Popen(BT_AGENT_NINO, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        time.sleep(1)

        try:
            subprocess.check_output(BLUETOOTHCTL_REMOVE.format(target=target), shell=True)
        except subprocess.CalledProcessError as e:
            logging.info("legacy_pairing.py -> Error removing the device: {}".format(e.output))
            #return

        pid = None
        # Running a scan to find the target device
        try:
            command = subprocess.Popen(HCITOOL_SCAN, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid)         # for some reason doesn't accept tokenized exploit_command (leads to a bug)
            pid = command.pid
            command.wait(timeout=30)
            output = command.communicate()[0].decode()
            logging.info("legacy_pairing.py -> output from HCITOOL_SCAN : " + str(output))
        except subprocess.TimeoutExpired as e:
            for child in psutil.Process(pid).children(recursive=True):
                child.kill()
            os.killpg(os.getpgid(command.pid), signal.SIGTERM)
            time.sleep(1)

        if output is not None and target in output:
            time.sleep(1)
            

            # Required to get information about the device, otherwise won't connect
            try:
                output = subprocess.check_output(HCITOOL_INFO.format(target=target), shell=True)
            except subprocess.CalledProcessError as e:
                logging.info("legacy_pairing.py -> Error getting information about the device: {}".format(e.output))

            # Pair with the target device
            try:
                output = subprocess.check_output(BLUETOOTHCTL_PAIR.format(target=target), shell=True)
            except subprocess.CalledProcessError as e:
                logging.info("legacy_pairing.py -> Error pairing with the device: {}".format(e.output))
                #return

            # Connect to the paired device
            print("Connecting the first time. Remember a code")
            try:
                output = subprocess.check_output(BLUETOOTHCTL_CONNECT.format(target=target), shell=True).decode()
            except subprocess.CalledProcessError as e:
                logging.info("legacy_pairing.py -> Error connecting to the device: {}".format(e.output))
            
            print("Connecting the second time. Check that the code is the same as before")
            try:
                output = subprocess.check_output(BLUETOOTHCTL_CONNECT.format(target=target), shell=True).decode()
            except subprocess.CalledProcessError as e:
                logging.info("legacy_pairing.py -> Error connecting to the device: {}".format(e.output))
                #report_error("Couldn't connect to a device, error while connecting")
            
    except Exception as e:
        logging.info("legacy_pairing.py -> Error: {}".format(str(e)))
        report_error("legacy_pairing.py -> strange error: {}".format(str(e)))
    finally:
        if 'process' in locals():
            process.terminate()
            try:
                process.communicate(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
        logging.info("legacy_pairing.py -> Finished")
    
    while True:
        answer = input("\nIf the device didn't show you buttons to pair and deny pairing then it is vulnerable\nIs it vulnerable?(Yes/No/Error):\n")
        print(answer)
        if answer.lower() == "yes":
            report_vulnerable("vuln")
            break
        elif answer.lower() == "no":
            report_vulnerable("no")
            break
        elif answer.lower() == "erorr":
            report_error("error")
            break
        else:
            print("Didn't understand your input. It should be one of the following: Yes/No/Error")

    


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--target', required=False, type=str, help="target MAC address")
    args = parser.parse_args()

    logging.basicConfig(filename=LOG_FILE, level=logging.INFO)

    if args.target:
        print(INSTRUCTIONS)
        check_legacy_pairing(args.target)
    else:
        parser.print_help()
